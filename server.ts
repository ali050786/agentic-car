import express from 'express';
import cors from 'cors';
import { YoutubeTranscript } from 'youtube-transcript';
import dotenv from 'dotenv';

dotenv.config();

const app = express();
const PORT = 3001;

// Enable CORS for all origins (in development)
app.use(cors());
app.use(express.json());

app.get('/api/doodles-input', async (req, res) => {
    try {
        const fs = await import('fs/promises');
        const path = await import('path');
        const filePath = path.join(process.cwd(), 'image-1.json');
        const data = await fs.readFile(filePath, 'utf-8');
        res.json(JSON.parse(data));
    } catch (error: any) {
        res.status(500).json({ error: error.message });
    }
});

app.get('/api/image-output', async (req, res) => {
    try {
        const fs = await import('fs/promises');
        const path = await import('path');
        const filePath = path.join(process.cwd(), 'image_output.json');

        // Check if file exists first
        try {
            await fs.access(filePath);
        } catch {
            return res.json([]); // Return empty array if file doesn't exist yet
        }

        const data = await fs.readFile(filePath, 'utf-8');
        res.json(JSON.parse(data));
    } catch (error: any) {
        res.status(500).json({ error: error.message });
    }
});

// YouTube transcript endpoint
app.post('/api/youtube-transcript', async (req, res) => {
    try {
        const { videoId } = req.body;

        if (!videoId) {
            return res.status(400).json({ error: 'Video ID is required' });
        }

        console.log(`[Backend] Fetching transcript for video: ${videoId}`);

        // Fetch transcript
        const transcriptItems = await YoutubeTranscript.fetchTranscript(videoId);

        if (!transcriptItems || transcriptItems.length === 0) {
            return res.status(404).json({
                error: 'No transcript available for this video. The video may not have captions.'
            });
        }

        // Combine all transcript items into a single text
        const fullTranscript = transcriptItems
            .map(item => item.text)
            .join(' ')
            .replace(/\s+/g, ' ')
            .trim();

        console.log(`[Backend] Successfully fetched transcript (${fullTranscript.length} characters)`);

        res.json({ transcript: fullTranscript });

    } catch (error: any) {
        console.error('[Backend] Error fetching transcript:', error);
        res.status(500).json({ error: error.message });
    }
});

// Replicate generation endpoint (simpler now)
app.post('/api/generate-doodle', async (req, res) => {
    try {
        const { topic, prompt } = req.body;

        if (!prompt) {
            return res.status(400).json({ error: 'Prompt is required' });
        }

        const replicateToken = process.env.REPLICATE_API_TOKEN;
        if (!replicateToken) {
            return res.status(500).json({ error: 'Missing REPLICATE_API_TOKEN' });
        }

        console.log(`[Backend] Generating doodle for: ${topic}`);

        const replicateResponse = await fetch('https://api.replicate.com/v1/models/black-forest-labs/flux-schnell/predictions', {
            method: 'POST',
            headers: {
                'Authorization': `Token ${replicateToken}`,
                'Content-Type': 'application/json',
                'Prefer': 'wait'
            },
            body: JSON.stringify({
                input: {
                    prompt: prompt,
                    go_fast: true,
                    megapixels: "1",
                    num_outputs: 1,
                    aspect_ratio: "2:3",
                    output_format: "webp",
                    output_quality: 90,
                    num_inference_steps: 4
                }
            })
        });

        if (!replicateResponse.ok) {
            const errText = await replicateResponse.text();
            throw new Error(`Replicate error: ${errText}`);
        }

        const prediction = await replicateResponse.json();
        const replicateUrl = prediction.output?.[0];

        if (!replicateUrl) {
            throw new Error('No image generated by Replicate');
        }

        console.log(`[Backend] Image generated at: ${replicateUrl}`);
        res.json({ replicateUrl });

    } catch (error: any) {
        console.error('[Backend] Error:', error);
        res.status(500).json({ error: error.message });
    }
});

// Proxy endpoint to fetch image as blob without CORS issues
app.get('/api/proxy-image', async (req, res) => {
    const { url } = req.query;
    if (!url || typeof url !== 'string') {
        return res.status(400).send('URL is required');
    }

    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('Failed to fetch image');

        const arrayBuffer = await response.arrayBuffer();
        const buffer = Buffer.from(arrayBuffer);

        res.setHeader('Content-Type', response.headers.get('Content-Type') || 'image/webp');
        res.send(buffer);
    } catch (error: any) {
        res.status(500).send(error.message);
    }
});

// Endpoint to save output JSON
app.post('/api/save-image-output', async (req, res) => {
    try {
        const fs = await import('fs/promises');
        const path = await import('path');
        const data = req.body;

        const filePath = path.join(process.cwd(), 'image_output.json');
        await fs.writeFile(filePath, JSON.stringify(data, null, 4));

        console.log(`[Backend] Saved output to ${filePath}`);
        res.json({ success: true, path: filePath });
    } catch (error: any) {
        console.error('[Backend] Error saving file:', error);
        res.status(500).json({ error: error.message });
    }
});

// Health check endpoint
app.get('/api/health', (req, res) => {
    res.json({ status: 'ok', message: 'YouTube Transcript API is running' });
});

app.listen(PORT, () => {
    console.log(`ğŸš€ YouTube Transcript Backend running on http://localhost:${PORT}`);
    console.log(`ğŸ“ API endpoint: http://localhost:${PORT}/api/youtube-transcript`);
});
